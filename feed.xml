<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://choieungi.github.io/</id><title>Ruggy Blog</title><subtitle>Junior Software Engineer, Spring boot</subtitle> <updated>2024-04-01T00:05:02+09:00</updated> <author> <name>Eungi, Choi</name> <uri>https://choieungi.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://choieungi.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="ko" href="https://choieungi.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2024 Eungi, Choi </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Spring Boot에서 CacheManager를 에러 핸들링하는 방법</title><link href="https://choieungi.github.io/posts/spring-boot-cahce-error-handling/" rel="alternate" type="text/html" title="Spring Boot에서 CacheManager를 에러 핸들링하는 방법" /><published>2024-03-31T11:22:00+09:00</published> <updated>2024-04-01T00:04:28+09:00</updated> <id>https://choieungi.github.io/posts/spring-boot-cahce-error-handling/</id> <content src="https://choieungi.github.io/posts/spring-boot-cahce-error-handling/" /> <author> <name>Eungi, Choi</name> </author> <category term="Development" /> <summary> 본 글은 아래 링크의 글의 내용과 이어집니다. https://choieungi.github.io/posts/spring-redis-cache-serialization-exception Spring에서 제공하는 @Cacheable을 이용하면 캐쉬를 AOP 기반으로 쉽게 사용할 수 있습니다. 이전 글에서 다뤘듯, 기본적으로 @Cacheable 을 실행하는 Aspect 메소드에서 예외가 발생하면 전체 메소드 자체가 실패하게 됩니다. 해당 상황에서 에러 핸들링을 통해 특정 상황에서 Exception이 발생하지 않도록 변경하는 방법을 소개합니다. @Cacheable 의 CacheErrorHandler 동작 원리 Spring 문서에 따르면 Error Handler는 SimpleCacheErrorHa... </summary> </entry> <entry><title>분산 시스템 환경에서 Spring Cloud Bus 없이 Spring Cloud Config 프로퍼티 Refresh하는 방법</title><link href="https://choieungi.github.io/posts/spring-cloud-refresh/" rel="alternate" type="text/html" title="분산 시스템 환경에서 Spring Cloud Bus 없이 Spring Cloud Config 프로퍼티 Refresh하는 방법" /><published>2024-01-21T16:12:00+09:00</published> <updated>2024-01-21T22:50:10+09:00</updated> <id>https://choieungi.github.io/posts/spring-cloud-refresh/</id> <content src="https://choieungi.github.io/posts/spring-cloud-refresh/" /> <author> <name>Eungi, Choi</name> </author> <category term="Development" /> <summary> 근래에 요즘 우아한 개발이라는 책을 읽으면서 내용 중에 배포 없이 Spring Cloud Config에서 받아오는 프로퍼티를 변경해 서버에 적용하려는 내용을 접했습니다. 해당 팀은 외부 메시지 플랫폼을 이중화하면서 각 외부 플랫폼 연동에 대한 트래픽 분배를 어플리케이션 실행 중에도 변경할 수 있도록 구현해 단일 장애 지점(SPOF)을 제거하려 했습니다. 이를 위해 어플리케이션의 배포 없이 Config 서버의 프로퍼티를 변경함으로 트래픽 분배를 변경하는 방법을 고려했고, 팀에서 최종적으로 일반적으로 사용하는 Spring Cloud Bus를 이용하기보다 Spring Boot만을 활용해 프로퍼티를 재배포 없이 수정하는 방법을 선택했습니다. 이 부분이 흥미롭게 느껴져 호기심에 구현해보게 되었습니다. 배포 ... </summary> </entry> <entry><title>Spring MVC에서 redisson으로 분산락을 구현하는 방법들</title><link href="https://choieungi.github.io/posts/spring-redis-distributed-lock/" rel="alternate" type="text/html" title="Spring MVC에서 redisson으로 분산락을 구현하는 방법들" /><published>2023-12-24T23:13:00+09:00</published> <updated>2023-12-24T23:45:14+09:00</updated> <id>https://choieungi.github.io/posts/spring-redis-distributed-lock/</id> <content src="https://choieungi.github.io/posts/spring-redis-distributed-lock/" /> <author> <name>Eungi, Choi</name> </author> <category term="Development" /> <summary> 멀티 인스턴스 환경에서 동시성을 해결하는 방법으로 Redis의 이벤트 루프 기반 싱글스레드 특성을 이용해 분산락을 사용해 쉽게 해결할 수 있습니다. 동시 호출은 DB 데이터의 정합이 깨지거나 메시지 이벤트의 중복 발행 등 예상치 못한 동작으로 이어지는 경우가 많아 해결해야 하는 경우가 빈번합니다. 분산락은 동시성을 제어하기 위한 부가 기능으로 비즈니스 로직과 섞이지 않도록 관심사를 잘 분리하는게 좋습니다. 관련해서 스프링은 Dependency Injection, AOP와 같은 여러 기능을 쉽게 사용할 수 있어 여러 구현 방법을 소개해보려 합니다. 구현은 Java, Spring MVC 기반으로 Redisson을 이용해 구현할 예정입니다. 요구사항 분산락이 실패하는 경우 null을 리턴하게 됩니... </summary> </entry> <entry><title>Spring Boot에서 Redis @Cacheable을 사용할 때 주의할 점</title><link href="https://choieungi.github.io/posts/spring-redis-cache-serialization-exception/" rel="alternate" type="text/html" title="Spring Boot에서 Redis @Cacheable을 사용할 때 주의할 점" /><published>2023-12-10T23:30:00+09:00</published> <updated>2023-12-24T23:09:02+09:00</updated> <id>https://choieungi.github.io/posts/spring-redis-cache-serialization-exception/</id> <content src="https://choieungi.github.io/posts/spring-redis-cache-serialization-exception/" /> <author> <name>Eungi, Choi</name> </author> <category term="Development" /> <summary> 사내에서 패키지 구조 변경 작업을 하고 배포를 했는데 갑자기 특정 API에서 transaction silently rolled back이 발생했었습니다. 관련해서 확인해보니 DB조회 값을 Dto 객체로 변환해 캐싱한 값을 역직렬화하는 과정에서 문제가 발생했었습니다. 해당 캐시는 월마다 한번씩 바뀌는 주기를 갖는 값으로, 조회가 많은 비율을 차지합니다. 캐시로 사용하는 정보가 DB에서 열거형으로 관리되고 있어 이를 자바 Dto 객체로 직렬화해서 redis에 저장해 캐시로 활용하고 있었습니다. 코드를 확인해보면 다음과 같습니다. 문제 상황 설정 값들 // package com.example.redisinactions.api; @Getter @AllArgsConstructor(access = Ac... </summary> </entry> <entry><title>MySQL 커넥션, I/O 연산, 잠금에 대한 고찰</title><link href="https://choieungi.github.io/posts/mysql-resources/" rel="alternate" type="text/html" title="MySQL 커넥션, I/O 연산, 잠금에 대한 고찰" /><published>2023-07-16T23:49:00+09:00</published> <updated>2023-07-16T23:49:00+09:00</updated> <id>https://choieungi.github.io/posts/mysql-resources/</id> <content src="https://choieungi.github.io/posts/mysql-resources/" /> <author> <name>Eungi, Choi</name> </author> <category term="Development" /> <summary> 실무에서 MySQL 데이터베이스를 활용하면서 커넥션, I/O 연산, 잠금에 대해 더 유심히 살펴보게 되었다. 요 세가지 자원이 중요하다고 배웠는데 실제로 사용해보면서 정말 그렇다는걸 느낄 수 있었다. 그렇기에 이를 통해 배운점들을 다시 상기해고자 한다. 커넥션 데이터베이스를 사용하면서 가장 중요한 자원을 꼽는다면 커넥션이다. 커넥션이 부족해지는 순간 쿼리를 날릴 수 없다는 의미이며, 이는 곧 장애로 이어진다. 그렇기에 데이터베이스 커넥션 개수를 원활하게 모니터링하고 관리하는 부분은 굉장히 중요하다. 커넥션이 부족해지게 만드는 요소로는 트래픽 증가로 서버의 스케일링으로 커넥션이 부족해질 때가 존재한다. 또, 트랜잭션이 길어져 해당 작업이 커넥션을 계속 잡고 있으면 db 커넥션이 부족해질 수 있다. ... </summary> </entry> </feed>
